//-----------------------------------------------------------------------------
// Filename: SIPResponse.cs
//
// Description: SIP Response.
//
// Author(s):
// Aaron Clauson (aaron@sipsorcery.com)
// 
// History:
// 17 Sep 2005	Aaron Clauson	Created, Dublin, Ireland.
//
// License: 
// BSD 3-Clause "New" or "Revised" License, see included LICENSE.md file.
//-----------------------------------------------------------------------------

using System;
using SIPSorcery.Sys;
using Microsoft.Extensions.Logging;

namespace SIPSorcery.SIP
{
    public enum SIPResponseParserError
    {
        None = 0,
        TooLarge = 1,
    }

    /// <summary>
    /// Represents a SIP Response.
    /// </summary>
    public class SIPResponse
	{
        private static ILogger logger = Log.Logger;
		
		private static string m_CRLF = SIPConstants.CRLF;
		private static string m_sipVersion = SIPConstants.SIP_FULLVERSION_STRING;
	
        /// <summary>
        /// The version string for the SIP response.
        /// </summary>
		public string SIPVersion;

        /// <summary>
        /// The status of the SIP response, e.g OK or NotAuthorized.
        /// </summary>
		public SIPResponseStatusCodesEnum Status;

        /// <summary>
        /// The status code of the SIP response, e.g. 200 for an OK response.
        /// </summary>
		public int StatusCode;

        /// <summary>
        /// The optional reason phrase for the SIP response.
        /// </summary>
		public string ReasonPhrase;

        /// <summary>
        /// The optional body or payload for the SIP response.
        /// </summary>
		public string Body;

        /// <summary>
        /// The SIP response's headers collection.
        /// </summary>
        public SIPHeader Header = new SIPHeader();

        /// <summary>
        /// Timestamp for the SIP response's creation.
        /// </summary>
        public DateTime Created = DateTime.Now;

        /// <summary>
        /// Warning: Generally this property does not need to be explcitily set. Only specific use
        /// cases such as a SIP Proxy application will need to adjust. The transport and transaction
        /// plumbing will take care of setting this property. Only adjust if you are sure of what
        /// you are doing.
        /// 
        /// For responses generated by us this is the remote SIP socket the response should be sent to.
        /// Note that the SIP transport class will attempt to determine the remote SIP end point based
        /// on the SIP response's Via header.
        /// 
        /// For responses received by us the remote SIP socket the response was received from.
        /// 
        /// Proxy servers that forward responses generated by an upstream SIP user agent are a special case.
        /// Proxy servers need to take care to not copy the received response and then send it. More than
        /// likely the local end point to send from and the remote end point to send to will be different
        /// for the next downstream server. In those cases the local and remote end point on the copied
        /// response can be set to null which will force the transport layer to use the SIP headers
        /// to determine the remote end point and the local channel to use.
        /// </summary>
        public SIPEndPoint RemoteSIPEndPoint;

        /// <summary>
        /// Warning: Generally this property does not need to be explcitily set. Only specific use
        /// cases such as a SIP Proxy application will need to adjust. The transport and transaction
        /// plumbing will take care of setting this property. Only adjust if you are sure of what
        /// you are doing.
        /// 
        /// For responses generated by us this is the local SIP socket the response should be sent from.
        /// If not set the SIP transport class can generally still attempt to determine the most appropriate
        /// channel to send the response on but in some cases with connection oriented channels like TCP,
        /// TLS and WebSockets the response is required to use the exact same connection the request
        /// was received on.
        /// 
        /// For responses received by us the local SIP socket the response was received on.
        /// 
        /// Proxy servers that forward responses generated by an upstream SIP user agent are a special case.
        /// Proxy servers need to take care to not copy the received response and then send it. More than
        /// likely the local end point to send from and the remote end point to send to will be different
        /// for the next downstream server. In those cases the local and remote end point on the copied
        /// response can be set to null which will force the transport layer to use the SIP headers
        /// to determine the remote end point and the local channel to use.
        /// </summary>
        public SIPEndPoint LocalSIPEndPoint;

        /// <summary>
        /// A short one line summary of the SIP response. Useful for logging or diagnostics.
        /// </summary>
        public string ShortDescription
        {
            get { return Header?.CSeqMethod + " " + StatusCode + " " + ReasonPhrase; }
        }

		private SIPResponse()
		{}

        /// <summary>
        /// SIPResponse Constructor.
        /// </summary>
        /// <param name="responseStatus">The status code for the response.</param>
        /// <param name="reasonPhrase">Optional description for the response. Should be kept short.</param>
        /// <param name="localSIPEndPoint">The local SIP end point the response was received on or should be sent from.</param>
        /// <param name="remoteSIPEndPoint">Optional remote SIP end point the response came from or should be sent to.
        /// If set as null the SIP transport layer will attempt to resolve the remote end point using the response's headers.</param>
        public SIPResponse(
            SIPResponseStatusCodesEnum responseStatus, 
            string reasonPhrase, 
            SIPEndPoint localSIPEndPoint, 
            SIPEndPoint remoteSIPEndPoint)
		{
			SIPVersion = m_sipVersion;
			StatusCode = (int)responseStatus;
            Status = responseStatus;
            ReasonPhrase = reasonPhrase;
			ReasonPhrase = responseStatus.ToString();
            LocalSIPEndPoint = localSIPEndPoint;
            RemoteSIPEndPoint = remoteSIPEndPoint;
		}

        /// <summary>
        /// Parses a SIP response from a SIP message object.
        /// </summary>
        /// <param name="sipMessage">The SIP message to parse a response from.</param>
        /// <returns>A new SIP response object.</returns>
		public static SIPResponse ParseSIPResponse(SIPMessage sipMessage)
		{
            try
            {
                SIPResponse sipResponse = new SIPResponse();
                sipResponse.LocalSIPEndPoint = sipMessage.LocalSIPEndPoint;
                sipResponse.RemoteSIPEndPoint = sipMessage.RemoteSIPEndPoint;
                string statusLine = sipMessage.FirstLine;

                int firstSpacePosn = statusLine.IndexOf(" ");

                sipResponse.SIPVersion = statusLine.Substring(0, firstSpacePosn).Trim();
                statusLine = statusLine.Substring(firstSpacePosn).Trim();
                sipResponse.StatusCode = Convert.ToInt32(statusLine.Substring(0, 3));
                sipResponse.Status = SIPResponseStatusCodes.GetStatusTypeForCode(sipResponse.StatusCode);
                sipResponse.ReasonPhrase = statusLine.Substring(3).Trim();

                sipResponse.Header = SIPHeader.ParseSIPHeaders(sipMessage.SIPHeaders);
                sipResponse.Body = sipMessage.Body;

                return sipResponse;
            }
            catch (SIPValidationException)
            {
                throw;
            }
            catch (Exception excp)
            {
                logger.LogError("Exception ParseSIPResponse. " + excp.Message);
                logger.LogError(sipMessage.RawMessage);
                throw new SIPValidationException(SIPValidationFieldsEnum.Response, "Error parsing SIP Response");
            }
		}

        /// <summary>
        /// Parses a SIP response from a string.
        /// </summary>
        /// <param name="sipMessageStr">The string to parse the SIP response from.</param>
        /// <returns>A new SIP response object.</returns>
        public static SIPResponse ParseSIPResponse(string sipMessageStr)
        {
            try
            {
                SIPMessage sipMessage = SIPMessage.ParseSIPMessage(sipMessageStr, null, null);
                return SIPResponse.ParseSIPResponse(sipMessage);
            }
            catch (SIPValidationException)
            {
                throw;
            }
            catch (Exception excp)
            {
                logger.LogError("Exception ParseSIPResponse. " + excp.Message);
                logger.LogError(sipMessageStr);
                throw new SIPValidationException(SIPValidationFieldsEnum.Response, "Error parsing SIP Response");
            }
        }

        /// <summary>
        /// Returns a string representing the full SIP response.
        /// </summary>
        /// <returns>A string representation of the SIP response.</returns>
		public override string ToString()
		{
			string reasonPhrase = (!ReasonPhrase.IsNullOrBlank()) ? " " + ReasonPhrase : null;

			string message = 
				SIPVersion + " " + StatusCode + reasonPhrase + m_CRLF +
				this.Header.ToString();

			if(Body != null)
			{
				message += m_CRLF + Body;
			}
			else
			{
				message += m_CRLF;
			}
			
			return message;
		}

        /// <summary>
        /// Creates an identical copy of the SIP Response for the caller.
        /// </summary>
        /// <returns>New copy of the SIPResponse.</returns>
        public SIPResponse Copy()
        {
            SIPResponse copy = new SIPResponse();
            copy.SIPVersion = SIPVersion;
            copy.Status = Status;
            copy.StatusCode = StatusCode;
            copy.ReasonPhrase = ReasonPhrase;
            copy.Header = Header?.Copy();
            copy.Body = Body;
            copy.Created = Created;
            copy.LocalSIPEndPoint = LocalSIPEndPoint?.CopyOf();
            copy.RemoteSIPEndPoint = RemoteSIPEndPoint?.CopyOf();

            return copy;
        }
	}
}
